[{"content":"Introdu√ß√£o Quase todo mundo que est√° inserido no mundo da programa√ß√£o conhece sobre Express√µes Regulares, mas, t√£o frequente quanto, o conhecimento fica s√≥ no \u0026ldquo;sobre\u0026rdquo;, mesmo: o modo de escrita, que beira a criptografia, e a falta de repert√≥rio para os casos de uso geram um sentimento generalizado de que RegEx √© ~basicamente~ m√°gica. Mas, diferente de m√°gica \u0026ldquo;de verdade\u0026rdquo;, conhecer o segredo e estragar a ilus√£o pode ser muito mais vantajoso.\nClaro, existem necessidades diferentes, que v√£o desde escrever uma express√£o simples para debugar o c√≥digo no seu editor, at√© fazer a extra√ß√£o de informa√ß√µes em dados n√£o estruturados, passando por melhorar a legibilidade de uma query no SQL. O que importa √© que, com um pouco de sitzfleisch, voc√™ pode adicionar mais uma ferramenta no seu arcabou√ßo e se tornar mais produtivo.\nA ideia do texto √© apenas molhar seus p√©s nesse universo, desmistificando o dialeto m√≠stico que separa os juniores dos s√™niors, a partir de uma compreens√£o mais palat√°vel.\nPuxando a cortina Para continuar a analogia da m√°gica, vamos puxar a cortina no meio do espet√°culo, tal qual o Mr. M. De forma simples, aquelas instru√ß√µes escritas em caracteres aparentemente aleat√≥rios s√£o instru√ß√µes para definir uma m√°quina de estados finita, basicamente um circuito l√≥gico com estados. Uma boa forma de entender esse conceito √© com o exemplo dispon√≠vel na p√°gina da Wikip√©dia: uma catraca.\nO estado \u0026ldquo;natural\u0026rdquo;, ou inicial, da catraca √© travada, voc√™ pode tentar empurrar, mas ela continua travada. A partir do momento que voc√™ passa o seu cart√£o com cr√©ditos suficiente, a catraca √© destravada. Ela fica nesse estado at√© que voc√™ a empurre, fazendo com que ela retorne ao estado natural.\nT√°, mas como n√≥s transportamos essa ideia para identificar um texto?\nVou responder isso usando um exemplo: suponha que voc√™ deseje criar uma dessas m√°quinas de estados finita que reconhe√ßa palavras entre aspas. Nesse caso, n√≥s teremos tr√™s estados:\nEstado inicial: vamos percorrer nosso texto, caracter a caracter, come√ßando aqui. Esse estado indica, efetivamente, que estamos come√ßando uma nova busca. S√≥ iremos passar pro pr√≥ximo, caso encontremos o caracter \u0026quot; (aspas duplas). Estado intermedi√°rio: encontramos o in√≠cio, agora precisamos achar o fim. Tudo que for letra encontrada pelo caminho n√£o altera o estado, a √∫nica coisa capaz de fazer com que n√≥s passemos de estado √©, novamente, o caracter \u0026ldquo;. Estado final: se chegamos at√© aqui, significa que tivemos um match, ou seja, encontramos a combina√ß√£o de caracteres capaz de percorrer todo o nosso algoritmo e podemos retornar esse texto. Para exercitar a imagina√ß√£o, eu gosto de pensar em uma setinha em cima das letras, conforme percorremos o texto. A seta indica qual estado estamos, dizendo algo do tipo \u0026ldquo;Isso √© um A, n√£o √© um caracter que muda o meu estado\u0026rdquo; ou \u0026ldquo;Epa, encontrei uma aspa dupla, muda de estado e vamos esperar para encontrar a pr√≥xima\u0026rdquo;, como na ferramenta Regexp::Debugger. [1]\nProgramaticamente, poder√≠amos fazer algo similar da seguinte forma:\nestado = 1 # Estado inicial match = \u0026#39;\u0026#39; # Nosso match for caracter in texto: # Faz um loop, letra a letra, pelo texto if estado == 2: # Caso estejamos no estado intermedi√°rio, match += caracter # adiciona o caracter √† vari√°vel de match if caracter == \u0026#39;\u0026#34;\u0026#39;: # Se encontrar uma aspa dupla, estado += 1 # muda de estado if estado != 3: # A menos que o estado seja o final, match += caracter # adiciona o caracter √† vari√°vel de match Embora essas representa√ß√µes deixem a inten√ß√£o mais clara, a dificuldade de desenhar diagramas de m√°quinas de estados finitas para cada caso (particularmente os mais complexos) se tornou um problema. Mas o criador das express√µes regulares, Stephen Kleene, deu um jeito de abreviar isso, gerando a forma como escrevemos express√µes regulares hoje. Todas as linhas de c√≥digo poderiam ser substitu√≠do por uma √∫nica linha:\nimport re match = re.search(\u0026#39;\u0026#34;.*\u0026#34;\u0026#39;, texto).group() Bem mais compacto, n√©?\nPois ent√£o, se definirmos o seguinte texto:\ntexto = \u0026#34;\u0026#34;\u0026#34;Este √© um exemplo de texto que cont√©m \u0026#34;aspas duplas\u0026#34;!\u0026#34;\u0026#34;\u0026#34; Os dois c√≥digos resultam no mesmo valor para a vari√°vel match:\n\u0026ldquo;aspas duplas\u0026rdquo;\nNota do autor: re √© a biblioteca nativa de express√µes regulares do Python. A documenta√ß√£o est√° nas fontes, no final da p√°gina. üòâ\nO beab√° do RegEx Agora voc√™ pode dizer: \u0026ldquo;T√°, muito legal, muito interessante, mas isso n√£o me ajuda em nada a escrever RegEx\u0026rdquo;. Sim, verdade, mas √© importante construir essa intui√ß√£o antes de come√ßar a estudar de fato, porque assim tem menos decoreba e mais compreens√£o.\nSe eu tiver feito bem o meu trabalho, quando eu escrevi o RegEx ali em cima (\u0026quot;.*\u0026quot;), voc√™ achou legal como ele resume tanta coisa. E a ideia √© continuar nesse mote, ao inv√©s de voc√™ olhar um asterisco e falar \u0026ldquo;Que merda √© essa?!\u0026rdquo;, eu espero que voc√™, no m√≠nimo, reconhe√ßa seu poder sintetizador.\nPois bem, nessa linha, existem duas classes que podem definir um caracter numa express√£o regular:\nLiteral: √© quando o caracter representa ele pr√≥prio. A √© A. Se voc√™ quer saber se a palavra \u0026ldquo;Pa√ßoca\u0026rdquo; aparece no texto, basta usar a pr√≥pria palavra. Reservado: um caracter √© reservado, ou especial, quando o seu significa surpassa o seu simbolo, um bom exemplo √© o j√° mencionado asterisco, que representa a repeti√ß√£o de um caracter \u0026ldquo;zero ou mais vezes\u0026rdquo;. Ou seja, um RegEx como b*d√° match com \u0026rsquo; \u0026lsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;bb\u0026rsquo;, \u0026lsquo;bbb\u0026rsquo; e assim por diante. √Äs vezes, voc√™ precisa usar um caracter reservado como literal, para isso usamos a barra invertida \\. Ou seja, para usar o asterisco como asterisco, e n√£o como \u0026ldquo;zero ou mais vezes\u0026rdquo;, basta colocar \\*.\nMas o que acontece se a gente usar a barra invertida em um literal?\nBom, na maioria das vezes, nada. Mas algumas combina√ß√µes s√£o, pasmem, boas sintetizadoras. Por exemplo, caso voc√™ queira encontrar um n√∫mero de um digito, ou seja 0 ou 1 ou 2 ou\u0026hellip; ou 9. Voc√™ pode fazer um RegEx assim:\nre.search(\u0026#39;0|1|2|3|4|5|6|7|8|9\u0026#39;, texto).group() # A barra vertical, |, indica \u0026#34;ou\u0026#34;. Ou voc√™ pode usar \\d - Qualquer digito num√©rico. Claro, quem conhece um pouquinho de RegEx deve estar me xingando pela forma acima, que nunca seria utilizada, sendo prefer√≠vel a forma mais compacta: [0-9]. Mas eu prometo que n√£o vou deixar ponto sem n√≥, tudo tem um motivo (sim, at√© o \u0026quot;.*\u0026quot;, pros mais avan√ßados).\nE, com isso, a gente j√° tem os pilares para come√ßar a construir algumas express√µes progressivamente mais dif√≠ceis.\nVelocidade um na dan√ßa do cr√©u Essa primeira parte √© a que todo usu√°rio de computador conhece: quando voc√™ aperta ctrl+f (ou cmd+f üçé) para pesquisar uma palavra em uma p√°gina da web. Voc√™ digita a palavra que voc√™ est√° procurando e ela √© grifada na p√°gina. √â pura e simplesmente o uso de uma express√£o literal.\nEmbora isso possa parecer t√£o √≥bvio que voc√™ talvez nem perceba, esse √© um dos casos mais utilizados, na minha experi√™ncia. Por exemplo, voc√™ est√° analisando um banco de dados de produtos de moda e quer ver todos os produtos com cor rosa, para fazer um marketing de oportunidade pro filme da Barbie, basta rodar uma query assim:\nSELECT * FROM tabela_produtos WHERE LOWER(nome_produto) LIKE \u0026#39;rosa\u0026#39; Assim n√≥s encontramos aqueles produtos como \u0026ldquo;Camiseta M B√°sica Rosa\u0026rdquo; ou \u0026ldquo;Salto Alto Rosa\u0026rdquo;. O problema √© que muitas vezes o analista n√£o conhece muito de RegEx (ou aprendeu esse \u0026ldquo;truque\u0026rdquo; do LIKE e replica, sem pensar muito no que est√° fazendo) e a query rapidamente vira uma macarronada com dezenas de linhas fazendo v√°rios filtros de LIKE na mesma coluna.\nPara resolver isso\u0026hellip;\nVelocidade dois na dan√ßa do cr√©u Aqui a gente come√ßa a adicionar alguns daqueles caracteres reservados. Seja usando a j√° mencionada barra vertical ou os colchetes. Por exemplo, em uma lista de cidades com o nome da seguinte forma:\nCidade, Estado (Ex: S√£o Paulo, SP)\nComo podemos contar quantas cidades s√£o da regi√£o Norte?\nimport re qtd_cidades_norte = len(re.findall(\u0026#34;AC|AM|AP|PA|RO|RR|TO\u0026#34;, lista_cidades)) Agora, se voc√™ quisesse saber quais s√£o essas cidades, fica um pouco mais dif√≠cil. No caso do RegEx que eu escrevi ali, ele vai procurar as siglas dos estados no texto e adicionar essas siglas √† lista. Por isso ela √© √∫til s√≥ pra fazer a contagem. Ou em casos espec√≠ficos, como quando voc√™ √© mais liberal com a sua defini√ß√£o da cor rosa:\nSELECT * FROM tabela_produtos WHERE REGEXP_LIKE(nome_produto, \u0026#39;rosa|rox[ao]\u0026#39;, \u0026#39;i\u0026#39;) Parece que eu adicionei muita coisa de uma vez, mas vamos por partes:\nAl√©m da cor rosa, tamb√©m vamos procurar as pe√ßas com a cor roxa, portanto rosa|roxa. Roxo, por√©m, √© um adjetivo que possui flex√µes diferentes, conforme o g√™nero do substantivo (\u0026ldquo;Camiseta Roxa\u0026rdquo; ou \u0026ldquo;Len√ßo Roxo\u0026rdquo;), diferente do rosa. Assim, precisamos levar em considera√ß√£o as duas vers√µes. Mas, ao inv√©s de escrever rosa|roxa|roxo, como a ra√≠z \u0026ldquo;rox\u0026rdquo; √© igual para as duas palavras, podemos fazer o seguinte: rox[ao], ou seja, \u0026ldquo;Encontre uma palavra que come√ßa com \u0026lsquo;rox\u0026rsquo; e termina com \u0026lsquo;a\u0026rsquo; ou \u0026lsquo;o\u0026rsquo;\u0026rdquo;. Portanto: rosa|rox[ao]. Ao inv√©s de usar o LIKE, eu estou utilizando REGEXP_LIKE, para poder usar a flag i, que indica que n√£o vou fazer diferencia√ß√£o entre letras mai√∫sculas e min√∫sculas. T√° ficando dif√≠cil, ein?! At√© agora, n√£o escrevemos nada que salte os olhos como especialmente complexo. Mas nesse pr√≥ximo n√≠vel, a gente precisa come√ßar a incluir alguns daqueles s√≠mbolos diferentes.\nImagine, por exemplo, que voc√™ esteja auxiliando na digitaliza√ß√£o de documentos em uma empresa. Algu√©m j√° transformou os arquivos f√≠sicos em arquivos digitais, por√©m ainda √© preciso colocar alguns desses dados em bases de dados. Uma dessas informa√ß√µes √© a data de admiss√£o de todos os colaboradores. A sua chefa acabou de te pedir para fazer isso.\n√â evidente que esse trabalho n√£o seria t√£o compartimentado assim, mas, para fim de exemplo, exercite sua suspens√£o da descren√ßa: voc√™ s√≥ precisa salvar o nome do arquivo e a data de admiss√£o, depois algu√©m junta todos os dados do funcion√°rios em uma tabela, usando o nome de arquivo como chave prim√°ria.\nO documento √© um .txtque toma a seguinte forma:\nNome: Fulano de Tal\nCargo: Engenheiro de Dados\nData de Nascimento: 01/01/1990\nData de Admiss√£o: 01/01/2020\nUma boa forma de come√ßar √© pegar s√≥ a parte que voc√™ quer e garantir que voc√™ est√° conseguindo corresponder com ela. No nosso caso, queremos uma data com o formato DIA/M√äS/ANO, ou seja: dois digitos num√©ricos + / + dois digitos num√©ricos + / + quatro digitos num√©ricos:\nimport re re.search(\u0026#39;\\d\\d/\\d\\d/\\d\\d\\d\\d\u0026#39;, \u0026#39;01/01/2020\u0026#39;).group() Claro, se voc√™ j√° percebeu o modus operandi da ferramenta, h√° uma forma de simplificar a constru√ß√£o de caracteres iguais repetindo N vezes (quando N √© conhecido e fixo, j√° vimos que para vezes indeterminadas pode se usar o asterisco), usando as chaves, {N}:\nimport re re.search(\u0026#39;\\d{2}/\\d{2}/\\d{4}\u0026#39;, \u0026#39;01/01/2020\u0026#39;).group() As chaves podem, ainda, te dizer o m√°ximo e o m√≠nimo de repeti√ß√µes. Se voc√™ soubesse que em alguns casos o in√≠cio das datas foram omitidos (por exemplo \u0026ldquo;01/01/2020\u0026rdquo; sendo escrito como \u0026ldquo;1/1/20\u0026rdquo;), voc√™ poderia colocar a quantidade m√≠nima e m√°xima de repeti√ß√µes que voc√™ espera ver, usando a s√≠ntaxe {N√∫mero m√≠nimo de repeti√ß√µes, N√∫mero m√°ximo de repeti√ß√µes}:\nimport re re.search(\u0026#39;\\d{1,2}/\\d{1,2}/\\d{2,4}\u0026#39;, \u0026#39;01/01/2020\u0026#39;).group() S√≥ tem um problema\u0026hellip; Da mesma forma que o c√≥digo funciona para a data desejada, tamb√©m funciona para \u0026ldquo;99/99/9999\u0026rdquo;, que, obviamente, n√£o √© uma data. Se voc√™ tiver certeza que tudo est√° corretamente digitalizado, voc√™ poderia apenas usar o RegEx acima, mas √© poss√≠vel encontrar erros de digitaliza√ß√£o se voc√™ restringir um pouco o c√≥digo: sabemos que os dias s√≥ podem come√ßar com 0, 1, 2 ou 3, que os meses s√≥ podem come√ßar com 0 ou 1 e que o ano s√≥ pode come√ßar com 1 ou 2 (ou s√≥ 2, caso sua empresa tenha sido fundada depois do ano 2000), portanto podemos deixar nosso RegEx mais robusto (e confi√°vel) da seguinte forma:\nimport re re.search(\u0026#39;[0123]{0,1}\\d/[01]{0,1}\\d/[12]{0,1}\\d{2,3}\u0026#39;, \u0026#39;01/01/2020\u0026#39;).group() Agora t√° come√ßando a ficar com uma carinha legal, n√©?\nDepois disso fica f√°cil, a gente s√≥ precisa garantir que o RegEx pega a data de admiss√£o e n√£o a de nascimento, mas para isso basta usar o texto literal, que √© est√°tico:\nimport re re.search(\u0026#39;Data de Admiss√£o: [0123]{0,1}\\d/[01]{0,1}\\d/[12]{0,1}\\d{2,3}\u0026#39;, \u0026#39;Data de Admiss√£o: 01/01/2020\u0026#39;).group() Bom, na verdade, quase basta, porque se usarmos esse c√≥digo, ele vai trazer inclusive o texto \u0026ldquo;Data de Admiss√£o: \u0026ldquo;, que n√≥s n√£o queremos. Para separar o joio do trigo, n√≥s podemos utilizar grupos. Nesse caso, √© poss√≠vel adicionar um grupo de captura, usando o par√™nteses em torno da data. A√≠ sim, temos o c√≥digo completo para automatizar esse processo:\nfrom os import listdir from re import search lista_de_datas = list() diretorio = \u0026#34;/caminho/\u0026#34; # Caminho da pasta com os arquivos for documento in listdir(diretorio): if \u0026#39;.txt\u0026#39; in documento: # L√™ os documentos with open(diretorio + documento, \u0026#39;r\u0026#39;) as lupa: texto = lupa.read() # Salva o nome do documento e a data de admiss√£o em # uma tupla, e essa tupla em uma lista lista_de_datas.append( (documento, search(\u0026#39;Data de Admiss√£o: ([0123]{0,1}\\d/[01]{0,1}\\d/[12]{0,1}\\d{2,3})\u0026#39;, texto).group(1)) ) cr√©u cr√©u cr√©u cr√©u cr√©u\u0026hellip; (cr√©u )* üòÜ Tocamos brevemente no √∫ltimo ponto que quero fazer, na se√ß√£o anterior: o poder do RegEx como validador. Qualquer um que j√° teve a oportunidade de cuidar de um banco de dados com dados digitados por usu√°rio (como dados de cadastro), teve a experi√™ncia √∫nica de descobrir que pessoas que nasceram em 1822, ou que v√£o nascer em 3034, s√£o compradoras frequentes da sua loja.\nO ponto √©: essas informa√ß√µes n√£o s√£o sempre confi√°veis.\nNota do Autor: esta √© uma obra de fic√ß√£o. Os personagens, acontecimentos e nomes retratados s√£o inventados e qualquer semalhan√ßa com a realidade √© mera coincid√™ncia\nMas n√≥s podemos melhorar isso com uma camada de valida√ß√£o no cadastro: por que aceitar um dado que n√≥s j√° sabemos que √© errado? Validadores de CPF, por exemplo, s√£o t√£o comuns que viraram exerc√≠cio para estudantes de programa√ß√£o. Por que n√£o fazer o mesmo com validadores de outras informa√ß√µes, como emails e n√∫meros de telefone, para estudantes de RegEx?\nNa verdade, at√© tem um porqu√™\u0026hellip; Eu preciso ser sincero: a valida√ß√£o de email usando RegEx √© incompleta e extremamente confusa, por alguns motivos:\nDa mesma forma que um CPF estar no formato v√°lido, n√£o garante a exist√™ncia dele, um email v√°lido n√£o necessariamente existe. Para checar isso, √© necess√°rio o uso de outras ferramentas. Existem muitas formas de emails v√°lidos, principalmente formas que n√≥s n√£o temos contato no dia-a-dia, que s√£o raras e diferentes, mas\u0026hellip; MAS voc√™ entrar o seu email corretamente e o site n√£o aceitar, porque um programador teve pregui√ßa na hora de fazer um RegEx, √© uma das piores experi√™ncias poss√≠veis para um usu√°rio. Recomendo evitar, se voc√™ quiser mant√™-lo como cliente. Para um RegEx que obede√ßa √†s normas oficiais (pelo menos na √©poca em que foi escrita - N√£o, eu n√£o chequei), d√™ uma olhada na refer√™ncia [2]. Mas, aqui, vamos prezar pelo simples:\nO usu√°rio pode ter letras mai√∫sculas ou min√∫sculas, n√∫meros, \u0026ldquo;.\u0026rdquo;, \u0026ldquo;-\u0026rdquo; e \u0026ldquo;_\u0026rdquo;.\nO servidor ser√° apenas de alto n√≠vel e contendo apenas letras (isso significa que vamos ignorar o IP do servidor).\nIgualmente, vamos manter s√≥ dom√≠nios \u0026ldquo;.com\u0026rdquo;.\nAntes de prosseguir, quero s√≥ enfatizar mais uma vez: estou mais preocupado com o didatismo, use o c√≥digo abaixo com parcim√¥nia. Se voc√™ quer algo um pouco mais completo, esse site clama ter c√≥digos que funcionam 99,99% das vezes (Mas, ainda assim, a palavra de ordem √© ‚ú® parcim√¥nia ‚ú®. Experi√™ncia do usu√°rio √© importante).\nO fim √© mais f√°cil, ent√£o comecemos por ele:\nimport re re.search(\u0026#34;@[a-z]+.com$\u0026#34;, \u0026#39;@servidor.com\u0026#39;).group() Os principais servidores comerciais s√£o contemplados por essa regra, que diz, basicamente: Encontre um texto que come√ßa com o \u0026ldquo;@\u0026rdquo;, depois tem uma ou mais (uma ou mais est√° representado pelo +) letras min√∫sculas at√© encontrar o termo \u0026ldquo;.com\u0026rdquo;, que √© a √∫ltima parte do texto (representado pelo cifr√£o).\nEm cima disso, precisamos adicionar a parte do usu√°rio, que √© um pouco menos restritiva, pois ela pode conter letras mai√∫sculas [A-Z] ou min√∫sculas [a-z], n√∫meros [0-9], o ponto, o h√≠fen e a barra inferior.\nimport re re.search(\u0026#34;^[a-zA-Z0-9_\\.-]+@[a-z]+.com$\u0026#34;, \u0026#39;fulano.detal90@servidor.com\u0026#39;).group() Fizemos algo bem parecido, mas, ao inv√©s de considerar o fim do texto, $, estamos considerando o in√≠cio, ^, e ao inv√©s de considerarmos s√≥ as letras min√∫sculas, temos uma ou mais (+) de qualquer dos caracteres citados. Esse RegEx √© muito bom para enxugar uma lista de emails que vai ser usada em CRM, apesar de n√£o ser t√£o boa para valida√ß√£o.\nE talvez voc√™ esteja achando estranho o tom t√£o preocupado que estou tendo em rela√ß√£o √† valida√ß√£o. N√£o √© impress√£o sua, o tom √© propostial e eu vou te contar o porqu√™\u0026hellip;\nTamanho √© documento, SIM! Lembra que comentei que eu n√£o ia deixar ponto sem n√≥? Ent√£o, se voc√™ √© um bom aluno (ü§ì) e estiver testando junto com o texto, pode ter percebido que o \u0026quot;.*\u0026quot;funciona, pero no mucho. Porque, no exemplo cuidadosamente selecionado que dei, √© uma maravilha, mas se voc√™ coloca duas frases com aspas duplas, d√° tudo errado. Por que? Eu menti pra voc√™?!\nExiste mais de uma forma para chegar ao seu objetivo com RegEx e, a bem da verdade, existem formas melhores e piores. Essa que eu sugeri, √© uma das piores, porque o asterisco √© um modificador ganancioso, isso significa que ele pega o m√°ximo de caracteres poss√≠veis. Para o momento, ele estava mais do que suficiente, mas, depois de tudo que passamos juntos, acho que eu posso ter uma conversa mais s√©ria com voc√™.\nEscrever um bom RegEx √© sin√¥nimo de muitos testes e pensar fora da caixa, porque √© preciso ver se ele funciona em todas as situa√ß√µes em que voc√™ precisa que ele funcione e, t√£o importante quanto, n√£o funcione quando voc√™ precise que ele n√£o funcione. H√°, ainda, que se considerar a performace. Por isso, no geral, Express√µes regulares mais completas e mais longas, s√£o melhores. Se voc√™ tomar atalhos, sua performace, sua seguran√ßa ou os dois, podem sofrer.\nFoi exatamente isso que aconteceu com a Cloudflare, em 2019. Vale a pena a leitura da descri√ß√£o completa do problema no blog deles ([3]), especialmente se voc√™ se interessa por seguran√ßa, mas o resumo √©:\nUm engenheiro escreveu um c√≥digo RegEx para o WAF (Web Application Firewall) do servi√ßo. WAF √© um firewall espec√≠fico para chamadas HTTP, que visa proteger os servi√ßos de ataques maliciosos como SQL Injection ou outras formas de interagir com o servidor usando comandos \u0026ldquo;escondidos\u0026rdquo; na query. O c√≥digo era esse: (?:(?:\u0026quot;|\u0026rsquo;|]|}|\\|\\d|(?:nan|infinity|true|false|null|undefined|symbol|math)|`|-|+)+[)];?((?:\\s|-|~|!|{}||||+).(?:.=.*)))\nPela natureza desse tipo de a√ß√£o, que deve ser r√°pida para impedir que O Mais Novo Cyber Ataque‚Ñ¢Ô∏è cause estragos, algu√©m escreve um c√≥digo, h√° uma valida√ß√£o entre o time de engenharia, que aceita o Pull Request e o commit √© feito, sendo implementado em todos os servidores ao redor do globo em segundos, sem, naquele momento, todas as precau√ß√µes necess√°rias.\nN√£o haviam travas ou testes de consumo de CPU para barrar o RegEx, apenas travas de detec√ß√£o, isso fez que o c√≥digo mal otimizado, particularmente .*.*=.*, exigisse muito do CPU do servidor, para toda nova requisi√ß√£o. Em poucos minutos essa regra fritou os servidores globais da CloudFlare, deixando v√°rios servi√ßos fora do ar.\nO que aconteceu foi, basicamente, uma regra perigosa (Procure qualquer coisa de qualquer tamanho, seguida de qualquer coisa de qualquer tamanho, seguida de um igual, seguida de qualquer coisa de qualquer tamanho) e a falta de testes suficientes gerando um problema de escala global.\nO perigo nesse tipo de regra √© conhecido, damos a ele o nome Catastrophic Backtracking (Em tradu√ß√£o livre, seria algo como Marcha-r√© Catastr√≥fica): a regra √© escrita de uma maneira que o motor RegEx precisa checar m√∫ltiplas vezes uma mesma palavra, para verificar a exist√™ncia de correspond√™ncias.\nPor isso a √™nfase que estou tendo, particularmente em c√≥digos de valida√ß√£o, √© preciso testes e travas que protejam o ambiente contra essas situa√ß√µes catastr√≥ficas.\nConclus√£o As express√µes regulares s√£o uma das ferramentas mais poderosas na programa√ß√£o, ela pode, literalmente, transformar sua vida em um inferno ou agilizar seu trabalho em muitas vezes. Embora eu n√£o espere que voc√™ saia desse texto com a capacidade de escrever um c√≥digo RegEx capaz de encontrar n√∫meros primos (recomendo demais olhar isso, √© uma das coisas mais legais que j√° vi feitas com RegEx - [4]), eu espero que ele tenha sido √∫til para, ao menos, desmistificar os c√≥digos e te incentivar a finalmente estudar.\nCita√ß√µes [1] - Watch RegExes with Regexp::Debugger\n[2] - Mail::RFC822::Address: RegExp-based address validation [3] - How Regular Expressions and a WAF DoS-ed Cloudflare\n[4] - A regular expression to check for prime numbers\nFontes Regular Expressions, Computerphile, 2020-01-09. (Acesso em Julho de 2023)\nTutorial, RegExp.info (Acesso em Julho de 2023)\nDocumenta√ß√£o re, Python Software Foundation (Acesso em Julho de 2023)\nDocumenta√ß√£o do PostgreSQL, PostgreSQL Global Developmente Group (Acesso em Julho de 2023)\nUnder the Hood: Regular Expressions, Reindeer Effect, 2018-06-24 (Acesso em Julho de 2023)\nRegexes: The Bad, the Better, and the Best, Liz Bennett, 2015-06-18 (Acesso em Julho de 2023)\n","permalink":"https://pfalcao97.githubpages.io/blog/posts/regex/regex/","summary":"Introdu√ß√£o Quase todo mundo que est√° inserido no mundo da programa√ß√£o conhece sobre Express√µes Regulares, mas, t√£o frequente quanto, o conhecimento fica s√≥ no \u0026ldquo;sobre\u0026rdquo;, mesmo: o modo de escrita, que beira a criptografia, e a falta de repert√≥rio para os casos de uso geram um sentimento generalizado de que RegEx √© ~basicamente~ m√°gica. Mas, diferente de m√°gica \u0026ldquo;de verdade\u0026rdquo;, conhecer o segredo e estragar a ilus√£o pode ser muito mais vantajoso.","title":"Express√µes Regulares"},{"content":"Pedro Falc√£o Engenheiro de Dados @ Descomplica üáßüá∑\nSobre mim: Sou formado em Engenharia Mec√¢nica, pela Universidade de S√£o Paulo, mas, desde antes disso, trabalho com dados. Comecei a aprender conceitos de Python e aprendizado de m√°quina desde meu primeiro ano da universidade, em 2017, e desde ent√£o meu interesse por programa√ß√£o sempre cresceu. Minha maior paix√£o √© compartilhar conhecimento, ent√£o, por muitos anos, trabalhei na constru√ß√£o de projetos que poderiam me ajudar com esse objetivo, incluindo dar aulas e escrever um blog de comunica√ß√£o cient√≠fica. Atualmente, a maior parte do meu tempo livre √© voltada para adquirir conhecimento que me permita criar um canal para o ensino de conceitos em STEM (Sigla em ingl√™s que significa Ci√™ncia, Tecnologia, Engenharia e Matem√°tica). Tenho muitos planos para o futuro e espero compartilhar tudo isso em breve.\nSou apaixonado pela filosofia Open Source e tento usar e dar suporte ao movimento FOSS sempre que poss√≠vel, portanto, estou aberto a contribuir com qualquer projeto desse tipo. Al√©m disso, adoraria ajudar em projetos mais focados em matem√°tica (como problemas de otimiza√ß√£o e simula√ß√µes) e an√°lise de dados. Se quiser conversar √© s√≥ me chamar no meu LinkedIn!\nDesenvolvimento: Meu trabalho √© como Engenheiro de Dados, em uma empresa brasileira de educa√ß√£o, Descomplica. Trabalho diariamente com sistemas Python, SQL, GCP, Bash, Docker, Airflow e UNIX. Tamb√©m estou aprendendo Rust no meu tempo livre, ent√£o isso pode aparecer de vez em quando aqui! Como comentei, j√° trabalhei profissionalmente no desenvolvimento de (mas n√£o somente) sistemas de dados, ent√£o, em meu curr√≠culo, tenho dezenas de projetos em automa√ß√£o, otimiza√ß√£o de processos, Extra√ß√£o-Tratamento- Carregamento de pipelines, Escrita de relat√≥rios complexos de an√°lise de dados, cria√ß√£o de projetos de Machine Learning, desenvolvimento de algoritmos, cria√ß√£o de bots (para plataformas como Telegram e Slack) e visualiza√ß√£o de dados. Tamb√©m trabalhei em pequenos projetos para mim, especialmente an√°lise de dados e automa√ß√£o.\nUm projeto em que trabalhei em meu tempo livre, do qual estou particularmente orgulhoso, foi automatizar um pipeline que consiste em extrair dados n√£o estruturados de um arquivo PDF (incluindo transform√°-lo em um arquivo de texto e, em seguida, desenvolver v√°rios c√≥digos RegEx complexos para obter exatamente os dados que me interessam - Trabalhar com PDFs √© notoriamente dif√≠cil), trat√°-los, porque eles tinham v√°rios formatos de data e mais de uma moeda e, finalmente, carreg√°-los em uma planilha do Excel. Este processo foi feito para automatizar um problema de trabalho comum para minha ador√°vel namorada advogada. Post√¢mbulo: Ok, ent√£o isso era tudo que eu tinha para dizer que era minimamente interessante. Agora, a parte que voc√™ pode pular sem se preocupar: Meus gostos e desgostos!\nNa maioria das vezes, estou fazendo o que descrevi nas outras se√ß√µes, mas tamb√©m mexo regularmente com equipamentos de √°udio e impress√£o 3D. Tenho uma impressora 3D Ender 3, que uso para resolver pequenas inconveni√™ncias na vida das pessoas ao meu redor e uma infinidade de equipamentos de √°udio, meu IEM favorito √© o Ikko OH10 (ou Obsidian). Gosto de malhar e correr/caminhar pela cidade. Tamb√©m adoro jogar videogame, embora isso n√£o seja algo que eu tenha tanto tempo hoje em dia, entre os meus jogos favoritos, posso citar Disco Elysium, Half-Life e Deus Ex. Meu seriado preferido √© Seinfeld, com quem, segundo aquela linda namorada de quem falei, compartilho muitos maneirismos. Eu tento ler todos os dias antes de dormir e meu g√™nero favorito √© a comunica√ß√£o cient√≠fica.\n","permalink":"https://pfalcao97.githubpages.io/blog/aboutme/","summary":"Pedro Falc√£o Engenheiro de Dados @ Descomplica üáßüá∑\nSobre mim: Sou formado em Engenharia Mec√¢nica, pela Universidade de S√£o Paulo, mas, desde antes disso, trabalho com dados. Comecei a aprender conceitos de Python e aprendizado de m√°quina desde meu primeiro ano da universidade, em 2017, e desde ent√£o meu interesse por programa√ß√£o sempre cresceu. Minha maior paix√£o √© compartilhar conhecimento, ent√£o, por muitos anos, trabalhei na constru√ß√£o de projetos que poderiam me ajudar com esse objetivo, incluindo dar aulas e escrever um blog de comunica√ß√£o cient√≠fica.","title":""}]